"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[265],{2366:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=i(4848),t=i(8453);const s={sidebar_label:"CVPR-24-SSL-guidance",sidebar_position:3},o="Learned representation-guided diffusion models for large-image generation",r={id:"publications/cvpr_24",title:"Learned representation-guided diffusion models for large-image generation",description:"CVPR 2024",source:"@site/docs/publications/cvpr_24.md",sourceDirName:"publications",slug:"/publications/cvpr_24",permalink:"/docs/publications/cvpr_24",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"CVPR-24-SSL-guidance",sidebar_position:3},sidebar:"publicationsSidebar",previous:{title:"WACV-24-PathLDM",permalink:"/docs/publications/wacv_24"}},d={},l=[{value:"Abstract",id:"abstract",level:2}];function c(e){const n={h1:"h1",h2:"h2",p:"p",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"learned-representation-guided-diffusion-models-for-large-image-generation",children:"Learned representation-guided diffusion models for large-image generation"}),"\n",(0,a.jsxs)("div",{className:"infobox",children:[(0,a.jsx)("span",{class:"conference-title",children:"CVPR 2024"}),(0,a.jsx)(n.p,{children:"Alexandros Graikos*, Srikar Yellapragada*, Minh-Quan Le, Saarthak Kapse, Prateek Prasanna, Joel Saltz, Dimitris Samaras"}),(0,a.jsxs)("div",{class:"button-group",children:[(0,a.jsx)("button",{class:"button_class",onClick:()=>window.open("https://github.com/cvlab-stonybrook/Large-Image-Diffusion","_blank"),children:"Code"}),(0,a.jsx)("button",{class:"button_class",onClick:()=>window.open("https://arxiv.org/abs/2312.07330","_blank"),children:"arXiv"})]})]}),"\n",(0,a.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,a.jsx)(n.p,{children:"To synthesize high-fidelity samples, diffusion models typically require auxiliary data to guide the generation process. However, it is impractical to procure the painstaking patch-level annotation effort required in specialized domains like histopathology and satellite imagery; it is often performed by domain experts and involves hundreds of millions of patches. Modern-day self-supervised learning (SSL) representations encode rich semantic and visual information. In this paper, we posit that such representations are expressive enough to act as proxies to fine-grained human labels. We introduce a novel approach that trains diffusion models conditioned on embeddings from SSL. Our diffusion models successfully project these features back to high-quality histopathology and remote sensing images. In addition, we construct larger images by assembling spatially consistent patches inferred from SSL embeddings, preserving long-range dependencies. Augmenting real data by generating variations of real images improves downstream classifier accuracy for patch-level and larger, image-scale classification tasks. Our models are effective even on datasets not encountered during training, demonstrating their robustness and generalizability. Generating images from learned embeddings is agnostic to the source of the embeddings. The SSL embeddings used to generate a large image can either be extracted from a reference image, or sampled from an auxiliary model conditioned on any related modality (e.g. class labels, text, genomic data). As proof of concept, we introduce the text-to-large image synthesis paradigm where we successfully synthesize large pathology and satellite images out of text descriptions."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);